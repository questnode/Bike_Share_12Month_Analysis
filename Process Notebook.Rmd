---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


### Load Libraries
```{r}
library(geosphere)
library(dplyr)
library(ggplot2)
library(tidyverse)
```
## Setting folder and file locations for initial data loading.

```{r}
raw_csv_folder <- "C:\\Users\\rayyao\\Documents\\RStudio\\Case Study 1\\Analysis\\rawdata" #File path to the folder with the *.csv files
merged_file <- "C:\\Users\\rayyao\\Documents\\RStudio\\Case Study 1\\Analysis\\ETL\\tripdata_202111-202210FULLvr0.2(IDs Names Geo Filled).csv" 
```


### Preloading data step #1: Process all raw csv data in a folder into one single csv file (This step can be skipped if merged_trips csv already exists and dataset is being loaded from there)

```{r}
file_path_list <- fs::dir_ls(raw_csv_folder)
file_name_list <- list.files(raw_csv_folder)

merged_trips = data.frame()

#for initial data exploration, read only first 1000 lines in each csv using nrows=1000
for (i in seq_along(file_name_list)) {
  # my_content <- read.csv(file = file_path_list[[i]], nrows=20000)
  my_content <- read.csv(file = file_path_list[[i]])
  
  df <- data.frame(my_content)

  merged_trips <- rbind(merged_trips, df)
}



```


### Preloading data step #2: Write the merged data to a new csv file (This step can be skipped if merged_trips csv already exists and dataset is being loaded from there)
```{r}
write.table(merged_trips, file = merged_file, sep = ",",
  append = FALSE, quote = FALSE,
  col.names = TRUE, row.names = FALSE)
```



### Preloading data setp #3: Read pre-merged csv into dataframe (This step can be skipped if step #1 of preloading is ran, and merged_trips dataframe is already populated)

```{r}

merged_trips = read.csv(merged_file)
```

# Cleaning and Transforming
After iniitial exploratory exercise, there are a few tasks to be done before putting the data into analysis models.

## Filling in missing Station IDs
### Create a list of stations along with their names, IDs, and geos.
Earlier data did not contail station IDs, but has geo-coordinate that may be used reference to later data

First we want to generate an index of all unique station IDs with their geo-coordinates

```{r}
# Create a vector with all unique IDs found in the start_station_id and end_station_id columns
all_station_ids = sort(unique(unique(merged_trips$start_station_id), unique(merged_trips$end_station_id)))
# Remove blank ID
all_station_ids = all_station_ids[all_station_ids != ""]

station_list <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(station_list) <- c("id","name","lng","lat")

for (i in seq_along(all_station_ids)) {

  station_info <- (merged_trips %>% filter(start_station_id == all_station_ids[i]))[c("start_lng","start_lat","start_station_name")]
  
  station_list[nrow(station_list) + 1,] <- c(
    all_station_ids[i],
    names(sort(table(station_info$start_station_name),decreasing=T)[1]),
    names(sort(table(station_info$start_lng),decreasing=T)[1]),
    names(sort(table(station_info$start_lat),decreasing=T)[1])
  )
  
}

station_list[,c("lng","lat")] <- sapply(station_list[,c("lng","lat")], as.numeric)

```

### Mark missing start and/or end geo-coordinates
Some records are missing start and/or end geo-coordinates.  Their station id and name shall be marked as Missing_Start_ID/Missing_End_ID and Missing_Start_Name/Missing_End_Name
The values in the g

```{r}

merged_trips[is.na(merged_trips)] <- ""

merged_trips[,c("start_lat","start_lng","end_lat","end_lng")] <- sapply(merged_trips[,c("start_lat","start_lng","end_lat","end_lng")], as.numeric)


merged_trips[,c("end_station_name","end_station_id")][is.na(merged_trips$end_lat) | is.na(merged_trips$end_lng),] <- "Missing Data & Geo"
merged_trips[,c("start_station_name","start_station_id")][is.na(merged_trips$start_lat) | is.na(merged_trips$start_lng),] <- "Missing Data & Geo"


```


### Reference missing station data with the station info generated
Now that we have a full list of stations, we can use it to look up the missing data points in merged_trips.  This can be done in the following steps

1. Seek along each row in mergerd_trips

2. Check to see if one or more of these cells is empty: start_station_name, start_station_id, end_station_name, end_station_id

3. If #2 is true, then the start/end lng/lat columns will be used. eg.

    If start_station_name or start_station_id is missing, then use start_lat and start_lng
  
    If end_station_name or end_station_id is missing, then use end_lat and end_lng
  
4. lat and lng values from merged_trips will be compared against all lat and lng values in station_list to determine which station is the missing value.  Match is determined when the total difference of lat & lng from merged trips and lat & lng from stastion_list is the smallest out of the entire list.

5. For precaution, the distance between the original geo-coordinates and the matched station will be recorded to see if there is a large deviation


```{r}
station_by_geo <- function(check_lat, check_lng) {
  # create a dictionary with two keys, one is the station ID, and the other is station name

  station_found <- c("id" = "", "name" = "")
  
  compare_list <- data.frame(station_list)
  compare_list <- compare_list%>%dplyr::mutate(Geo_Diff=NA)
  compare_list[,"Geo_Diff"] <- abs(compare_list[,"lat"]-check_lat) + abs(compare_list[,"lng"]-check_lng)
  
  row_num = which.min(compare_list[,"Geo_Diff"])
  
  station_found["id"] <- compare_list[row_num,"id"]
  station_found["name"] <- compare_list[row_num,"name"]

  return(station_found)

}
```

## Run search for blank station names and IDs by maching geo-coordinates

```{r}
# === Start Stations ===
station_ids_found = numeric (nrow(merged_trips))
station_names_found = numeric (nrow(merged_trips))

condition <- (merged_trips$start_station_name == "" | merged_trips$start_station_id == "")

start_station_ids_found = numeric (nrow(merged_trips))
start_station_names_found = numeric (nrow(merged_trips))

case <- 0

for (i in 1:nrow(merged_trips)) {

  if (i %% 10000 == 0 | i == 1) {
    print(paste("Start Station Record # ", i ,". @ ", Sys.time(), ". Case found: ", case, sep=""))
  }

  if (condition[i]) {
    station_found <- station_by_geo(merged_trips[i,"start_lat"],merged_trips[i,"start_lng"])
    start_station_ids_found[i] <- station_found["id"]
    start_station_names_found[i] <- station_found["name"]
    
    case <- case + 1
  }
}
merged_trips$start_station_id <- ifelse(!merged_trips$start_station_id == "", merged_trips$start_station_id, start_station_ids_found)
merged_trips$start_station_name <- ifelse(!merged_trips$start_station_name == "", merged_trips$start_station_name, start_station_names_found)

### =========== End stations
end_station_ids_found = numeric (nrow(merged_trips))
end_station_names_found = numeric (nrow(merged_trips))

condition <- (merged_trips$end_station_name == "" | merged_trips$end_station_id == "")

case <- 0

for (i in seq_len(nrow(merged_trips))) {
  
  if (i %% 10000 == 0 | i == 1) {
    print(paste("End Station Record # ", i ,". At ", Sys.time(), ". Case found: ", case, sep=""))
    paste
  }

  if (condition[i]) {
    station_found <- station_by_geo(merged_trips[i,"end_lat"],merged_trips[i,"end_lng"])

    end_station_ids_found[i] <- station_found["id"]
    end_station_names_found[i] <- station_found["name"]
    
    case <- case + 1
  }
}

merged_trips$end_station_id <- ifelse(!merged_trips$end_station_id == "", merged_trips$end_station_id, end_station_ids_found)
merged_trips$end_station_name <- ifelse(!merged_trips$end_station_name == "", merged_trips$end_station_name, end_station_names_found)

```



### Add a column to calculate linear distance between starting and ending stations

```{r}
merged_trips <- merged_trips%>%dplyr::mutate(linear_distance=geosphere::distHaversine(cbind(start_lng,start_lat), cbind(end_lng,end_lat)))
```


### Testing different models
```{r}
summary(merged_trips)
glimpse(merged_trips)

ggplot(data = merged_trips) +
  geom_bar(mapping = aes(x = rideable_type, fill=member_casual))
```



After initial exploration, data plan could be:
1. casual vs member at each station
2. casual vs member in ride distance 
3. casual vs member in ride duration
4. sort stations in most busy to least busy
5. 

Data fixes:
1. Fill in station names and IDs based on geo-coordinates
2. What is docked_bike rideable_type?

